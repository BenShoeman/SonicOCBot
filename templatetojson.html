<!DOCTYPE html>
<html>
<head>
  <title>Template to JSON - Sonic OC Bot</title>
  <style type="text/css">
  canvas, h2, h3, input[type="file"], p, form, div
  {
    display: block;
    margin-left: auto; margin-right: auto;
    text-align: center;
  }
  canvas
  {
    border: 1px solid;
    border-color: #ccc;
    margin-bottom: 0.75cm;
    cursor: crosshair;
    image-rendering: optimizeSpeed;             /* Older versions of FF          */
    image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
    image-rendering: -webkit-optimize-contrast; /* Safari                        */
    image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
    image-rendering: pixelated;                 /* Awesome future-browsers       */
    -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
  }
  form
  {
    margin-bottom: 0.75cm;
  }
  form > div
  {
    margin-bottom: 0.25cm;
  }
  textarea
  {
    display: block;
    margin-left: auto; margin-right: auto;
    width: 600px;
    height: 20px;
  }
  </style>
  <script>
  var examplecolors = [ [228,36,38], [242,143,32], [241,231,13], [10,144,93], [32,114,178], [110,57,141], [255,210,87] ];

  var tmp;
  function updateJSON()
  {
    if (tmp)
    {
      document.getElementById("jsoninfo").innerHTML = JSON.stringify(tmp);
    }
  }

  function hsv2rgb(h, s, v)
  {
    // Get HSV values and put them in range 0..1
    h = h*Math.PI/180; s = s/100; v = v/100;

    var r = v * (1 + s*(Math.cos(h)-1));
    var g = v * (1 + s*(Math.cos(h+2*Math.PI/3)-1));
    var b = v * (1 + s*(Math.cos(h-2*Math.PI/3)-1));

    // Return RGB values in range 0..255
    return [Math.max(0,Math.round(r*255)), Math.max(0,Math.round(g*255)), Math.max(0,Math.round(b*255))];
  }

  function rgb2hsv(r, g, b)
  {
    // Get RGB values and put them in range 0..1
    r = r/255.0; g = g/255.0; b = b/255.0;

    var c = r + g + b;
    if (c < 1e-4)
    {
      return [0.0, 2.0/3.0*100.0, 0.0];
    }
    else
    {
      var p = 2 * Math.sqrt(b*b + g*g + r*r - g*r - b*g - b*r);
      var h = Math.atan2(b-g, (2*r - b - g) / 3 ** 0.5);
      var s = p / (c + p);
      var v = (c + p) / 3;

      // Return HSV values in range 0..360 for hue, 0..100 otherwise
      return [h*180/Math.PI, s*100, v*100];
    }
  }

  function loadTemplate()
  {
    var canvas = document.getElementById("canvas");
    var c = canvas.getContext("2d");
    var template = new Image();

    template.onload = function() {
      canvas.setAttribute("width", template.width);
      canvas.setAttribute("height", template.height);
      canvas.setAttribute("onclick", "fillTemplate(event)");
      c.drawImage(template, 0, 0);
      tmp = {
        image: document.querySelector('input[type=file]').files[0].name,
        species: prompt("Enter species of template.").toLowerCase(),
        gender: prompt("Enter sex/gender of template.").toLowerCase(),
        fill: []
      };
      document.getElementById("tempinfo").style.display = "block";
      document.getElementById("tempinfo").innerHTML = "Species: " + tmp.species.replace(/^[a-z]/, function (x) {return x.toUpperCase()}) + "<br>Sex: " + tmp.gender.replace(/^[a-z]/, function (x) {return x.toUpperCase()}) + "<br><a href='javascript:;' onclick='loadTemplate()'>Reset Template</a>";
      document.getElementById("colorregion").style.display = "block";
      updateJSON();

      if (document.getElementById("colorregion").children.length > 1)
      {
        document.getElementById("colorregion").innerHTML = '<div id="addregion"><a href="javascript:;" onclick="addColorRegion()">+ Add color region...</a></div>';
      }

      addColorRegion();
    };

    var file = document.querySelector('input[type=file]').files[0];
    var reader = new FileReader();

    reader.onloadend = function () {
      template.src = reader.result;
    };

    if (file)
    {
      reader.readAsDataURL(file); //reads the data as a URL
    }
    else
    {
      template.src = "";
    }
  }

  function fillTemplate(evt)
  {
    var canvas = document.getElementById("canvas");
    var c = canvas.getContext("2d");

    var colornum = document.forms.colorregion.colorarea.value;
    if (tmp.fill[colornum].region == "skin") colornum = 6;
    var colormode = document.forms.colormode.colormode.value;

    switch (colormode)
    {
      case "":
        c.fillStyle = "rgb(" + examplecolors[colornum][0] + "," + examplecolors[colornum][1] + "," + examplecolors[colornum][2] + ")";
        break;
      case "shade":
        c.fillStyle = "rgb(" + Math.max(0,examplecolors[colornum][0]-30) + "," + Math.max(0,examplecolors[colornum][1]-30) + "," + Math.max(examplecolors[colornum][2]-30) + ")";
        break;
      case "tint":
        c.fillStyle = "rgb(" + Math.min(255,examplecolors[colornum][0]+45) + "," + Math.min(255,examplecolors[colornum][1]+45) + "," + Math.min(255,examplecolors[colornum][2]+45) + ")";
        break;
      case "complement":
        var hsv = rgb2hsv(examplecolors[colornum][0], examplecolors[colornum][1], examplecolors[colornum][2]);
        var newhsv = [hsv[0] + 180, hsv[1], hsv[2]];
        var rgb = hsv2rgb(newhsv[0], newhsv[1], newhsv[2]);
        c.fillStyle = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
        break;
      case "analogccw":
        var hsv = rgb2hsv(examplecolors[colornum][0], examplecolors[colornum][1], examplecolors[colornum][2]);
        var newhsv = [hsv[0] + 30, hsv[1], hsv[2]];
        var rgb = hsv2rgb(newhsv[0], newhsv[1], newhsv[2]);
        c.fillStyle = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
        break;
      case "analogcw":
        var hsv = rgb2hsv(examplecolors[colornum][0], examplecolors[colornum][1], examplecolors[colornum][2]);
        var newhsv = [hsv[0] - 30, hsv[1], hsv[2]];
        var rgb = hsv2rgb(newhsv[0], newhsv[1], newhsv[2]);
        c.fillStyle = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
        break;
    }

    var coord = [evt.offsetX, evt.offsetY];
    var coordtype = "coords" + (colormode == "" ? "" : "-" + colormode);
    var regionnum = document.forms.colorregion.colorarea.value;
    if (!tmp.fill[regionnum][coordtype])
    {
      tmp.fill[regionnum][coordtype] = [];
    }
    tmp.fill[regionnum][coordtype].push(coord);
    updateJSON();

    c.fillFlood(evt.offsetX, evt.offsetY, 0);
  }

  function addColorRegion()
  {
    var newregionnode = document.createElement("DIV");
    var colorregionchoices = document.getElementById("colorregion");
    var lastcolregionel = colorregionchoices.children.length-1;
    newregionnode.id = "region" + lastcolregionel; // Has the Add color region... node too, so don't count that

    var newnode = document.createElement("INPUT");
    newnode.type = "radio"; newnode.name = "colorarea";
    newnode.value = lastcolregionel; newnode.checked = lastcolregionel == 0;
    newregionnode.appendChild(newnode);

    var newnode = document.createElement("SPAN");
    newnode.style.color = "rgb(" + examplecolors[lastcolregionel][0] + "," + examplecolors[lastcolregionel][1] + "," + examplecolors[lastcolregionel][2] + ")";
    newnode.textContent = " " + lastcolregionel + " ";
    newregionnode.appendChild(newnode);

    var newnode = document.createElement("INPUT");
    newnode.style.color = "rgb(" + examplecolors[lastcolregionel][0] + "," + examplecolors[lastcolregionel][1] + "," + examplecolors[lastcolregionel][2] + ")";
    newnode.placeholder = "Name of color region...";
    newnode.setAttribute("onchange", "checkIfSkinRegion(this);updateRegionName(this)");
    newregionnode.appendChild(newnode);

    colorregionchoices.insertBefore(newregionnode, colorregionchoices.children[lastcolregionel]);
    newregionnode.lastChild.focus()

    tmp.fill.push({
      region: ""
    });
    updateJSON();

    if (colorregionchoices.children.length > 6)
    {
      colorregionchoices.removeChild(colorregionchoices.children[colorregionchoices.children.length-1]);
    }
  }

  function checkIfSkinRegion(field)
  {
    var fieldParent = field.parentNode;
    if (field.value == "skin")
    {
      var regionnum = 6;
      fieldParent.children[1].style.color = "rgb(" + examplecolors[regionnum][0] + "," + examplecolors[regionnum][1] + "," + examplecolors[regionnum][2] + ")";
      field.style.color = "rgb(" + examplecolors[regionnum][0] + "," + examplecolors[regionnum][1] + "," + examplecolors[regionnum][2] + ")";
    }
    else if (field.style.color == "rgb(255, 210, 87)")
    {
      var regionnum = parseInt(fieldParent.firstChild.value);
      fieldParent.children[1].style.color = "rgb(" + examplecolors[regionnum][0] + "," + examplecolors[regionnum][1] + "," + examplecolors[regionnum][2] + ")";
      field.style.color = "rgb(" + examplecolors[regionnum][0] + "," + examplecolors[regionnum][1] + "," + examplecolors[regionnum][2] + ")";
    }
  }

  function updateRegionName(field)
  {
    var fieldParent = field.parentNode;
    var regionnum = parseInt(fieldParent.children[1].textContent);
    tmp.fill[regionnum].region = field.value;
    updateJSON();
    fieldParent.firstChild.checked = true;
  }
  </script>
  <!-- context.fillFlood is Copyright (c) 2015 Max Irwin under The MIT License -->
  <script>
  var floodfill = (function() {

  	//Copyright(c) Max Irwin - 2011, 2015, 2016
  	//MIT License

  	function floodfill(data,x,y,fillcolor,tolerance,width,height) {

  		var length = data.length;
  		var Q = [];
  		var i = (x+y*width)*4;
  		var e = i, w = i, me, mw, w2 = width*4;

  		var targetcolor = [data[i],data[i+1],data[i+2],data[i+3]];

  		if(!pixelCompare(i,targetcolor,fillcolor,data,length,tolerance)) { return false; }
  		Q.push(i);
  		while(Q.length) {
  			i = Q.pop();
  			if(pixelCompareAndSet(i,targetcolor,fillcolor,data,length,tolerance)) {
  				e = i;
  				w = i;
  				mw = parseInt(i/w2)*w2; //left bound
  				me = mw+w2;             //right bound
  				while(mw<w && mw<(w-=4) && pixelCompareAndSet(w,targetcolor,fillcolor,data,length,tolerance)); //go left until edge hit
  				while(me>e && me>(e+=4) && pixelCompareAndSet(e,targetcolor,fillcolor,data,length,tolerance)); //go right until edge hit
  				for(var j=w;j<e;j+=4) {
  					if(j-w2>=0     && pixelCompare(j-w2,targetcolor,fillcolor,data,length,tolerance)) Q.push(j-w2); //queue y-1
  					if(j+w2<length && pixelCompare(j+w2,targetcolor,fillcolor,data,length,tolerance)) Q.push(j+w2); //queue y+1
  				}
  			}
  		}
  		return data;
  	};

  	function pixelCompare(i,targetcolor,fillcolor,data,length,tolerance) {
  		if (i<0||i>=length) return false; //out of bounds
  		if (data[i+3]===0 && fillcolor.a>0) return true;  //surface is invisible and fill is visible

  		if (
  			Math.abs(targetcolor[3] - fillcolor.a)<=tolerance &&
  			Math.abs(targetcolor[0] - fillcolor.r)<=tolerance &&
  			Math.abs(targetcolor[1] - fillcolor.g)<=tolerance &&
  			Math.abs(targetcolor[2] - fillcolor.b)<=tolerance
  		) return false; //target is same as fill

  		if (
  			(targetcolor[3] === data[i+3]) &&
  			(targetcolor[0] === data[i]  ) &&
  			(targetcolor[1] === data[i+1]) &&
  			(targetcolor[2] === data[i+2])
  		) return true; //target matches surface

  		if (
  			Math.abs(targetcolor[3] - data[i+3])<=(255-tolerance) &&
  			Math.abs(targetcolor[0] - data[i]  )<=tolerance &&
  			Math.abs(targetcolor[1] - data[i+1])<=tolerance &&
  			Math.abs(targetcolor[2] - data[i+2])<=tolerance
  		) return true; //target to surface within tolerance

  		return false; //no match
  	};

  	function pixelCompareAndSet(i,targetcolor,fillcolor,data,length,tolerance) {
  		if(pixelCompare(i,targetcolor,fillcolor,data,length,tolerance)) {
  			//fill the color
  			data[i]   = fillcolor.r;
  			data[i+1] = fillcolor.g;
  			data[i+2] = fillcolor.b;
  			data[i+3] = fillcolor.a;
  			return true;
  		}
  		return false;
  	};

  	function fillUint8ClampedArray(data,x,y,color,tolerance,width,height) {
  		if (!data instanceof Uint8ClampedArray) throw new Error("data must be an instance of Uint8ClampedArray");
  		if (isNaN(width)  || width<1)  throw new Error("argument 'width' must be a positive integer");
  		if (isNaN(height) || height<1) throw new Error("argument 'height' must be a positive integer");
  		if (isNaN(x) || x<0) throw new Error("argument 'x' must be a positive integer");
  		if (isNaN(y) || y<0) throw new Error("argument 'y' must be a positive integer");
  		if (width*height*4!==data.length) throw new Error("width and height do not fit Uint8ClampedArray dimensions");

  		var xi = Math.floor(x);
  		var yi = Math.floor(y);

  		if (xi!==x) console.warn("x truncated from",x,"to",xi);
  		if (yi!==y) console.warn("y truncated from",y,"to",yi);

  		//Maximum tolerance of 254, Default to 0
  		tolerance = (!isNaN(tolerance)) ? Math.min(Math.abs(Math.round(tolerance)),254) : 0;

  		return floodfill(data,xi,yi,color,tolerance,width,height);
  	};

  	var getComputedColor = function(c) {
  		var temp = document.createElement("div");
  		var color = {r:0,g:0,b:0,a:0};
  		temp.style.color = c;
  		temp.style.display = "none";
  		document.body.appendChild(temp);
  		//Use native window.getComputedStyle to parse any CSS color pattern
  		var style = window.getComputedStyle(temp,null).color;
  		document.body.removeChild(temp);

  		var recol = /([\.\d]+)/g;
  		var vals  = style.match(recol);
  		if (vals && vals.length>2) {
  			//Coerce the string value into an rgba object
  			color.r = parseInt(vals[0])||0;
  			color.g = parseInt(vals[1])||0;
  			color.b = parseInt(vals[2])||0;
  			color.a = Math.round((parseFloat(vals[3])||1.0)*255);
  		}
  		return color;
  	};

  	function fillContext(x,y,tolerance,left,top,right,bottom) {
  		var ctx  = this;

  		//Gets the rgba color from the context fillStyle
  		var color = getComputedColor(this.fillStyle);

  		//Defaults and type checks for image boundaries
  		left     = (isNaN(left)) ? 0 : left;
  		top      = (isNaN(top)) ? 0 : top;
  		right    = (!isNaN(right)&&right) ? Math.min(Math.abs(right),ctx.canvas.width) : ctx.canvas.width;
  		bottom   = (!isNaN(bottom)&&bottom) ? Math.min(Math.abs(bottom),ctx.canvas.height) : ctx.canvas.height;

  		var image = ctx.getImageData(left,top,right,bottom);

  		var data = image.data;
  		var width = image.width;
  		var height = image.height;

  		if(width>0 && height>0) {
  			fillUint8ClampedArray(data,x,y,color,tolerance,width,height);
  			ctx.putImageData(image,left,top);
  		}
  	};

  	if (typeof CanvasRenderingContext2D != 'undefined') {
  		CanvasRenderingContext2D.prototype.fillFlood = fillContext;
  	};

  	return fillUint8ClampedArray;

  })();
  </script>
</head>
<body>
  <h2>Sonic OC Bot Template to JSON</h2>
  <input type="file" onchange="loadTemplate()">
  <canvas id="canvas" width="0" height="0"></canvas>
  <p id="tempinfo" style="display:none;"></p>
  <form id="colormode">
    <input type="radio" name="colormode" value="" checked> Normal
    <input type="radio" name="colormode" value="shade"> Shaded
    <input type="radio" name="colormode" value="tint"> Tinted
    <input type="radio" name="colormode" value="complement"> Complementary
    <input type="radio" name="colormode" value="analogccw"> Analogous (CCW)
    <input type="radio" name="colormode" value="analogcw"> Analogous (CW)
  </form>
  <form id="colorregion" style="display:none;">
    <div id="addregion"><a href="javascript:;" onclick="addColorRegion()">+ Add color region...</a></div>
  </form>
  <p>JSON Output (Updates Automatically):</p>
  <textarea id="jsoninfo"></textarea>
  <div>
  <h3>NOTES:</h3>
    <p>Change the region name to "skin" if you want the bot to give it a realistic skin color. The preview flood-fill color for this region will change.</p>
    <p>Analogous colors go counter-clockwise and clockwise according to this color wheel:</p>
    <p><img src="data:image/gif;base64,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" style="width:75px;height:auto;"></p>
  </div>
</body>
</html>
